# CI/CD Integration with GitHub Actions

The MCP Gemini Adjudicator integrates with GitHub Actions to automatically verify AI claims on every pull request and push to main branches.

## Overview

The verification workflow (`.github/workflows/verify-claims.yml`) runs automatically on:
- Pull request creation, updates, and reopening
- Pushes to main/master branches
- Manual workflow dispatch with debug mode option

## Workflow Steps

### 1. Task Identification
- Generates unique task ID with timestamp and commit SHA
- Analyzes changed files to determine task type:
  - `code_update`: Changes to programming files (.js, .ts, .py, etc.)
  - `content`: Changes to documentation (.md, .txt, .rst)
  - `api_test`: Changes to API definitions
  - `general`: Other changes

### 2. Commitment Generation
Creates a commitment JSON with:
- Task ID and timestamp
- Task type based on file analysis
- GitHub context (PR number, commit SHA, actor)

### 3. Claim Generation
Generates a v1.1 compliant claim:
```json
{
  "schema": "verify.claim/v1.1",
  "actor": "github_actions",
  "task_id": "T_1234567890_abc12345",
  "timestamp": "2024-01-15T10:30:00Z",
  "claim": {
    "type": "code_update",
    "units_total": 5,
    "units_list": ["src/file1.js", "src/file2.js"],
    "scope": {
      "repo_root": "/path/to/repo",
      "files": ["src/file1.js", "src/file2.js"]
    },
    "declared": {
      "intent": "Verify changes in PR #123",
      "approach": "Automated verification via GitHub Actions",
      "completion_status": "complete"
    }
  }
}
```

### 4. Adapter Execution
Runs adapters based on task type and adapter plan:
- Discovers available adapters via manifests
- Executes capabilities in order (e.g., code:diff ‚Üí code:lint ‚Üí code:tests)
- Collects artifacts in task directory

### 5. Gate Enforcement
Applies verification profiles to artifacts:
- Fast path for deterministic pass/fail
- Checks thresholds (coverage, lint errors, etc.)
- Generates verdict without LLM if conclusive

### 6. Gemini Verification (Conditional)
If gate can't determine verdict:
- Sends artifacts to Gemini for analysis
- Applies active verification profile
- Generates final verdict

### 7. Reporting
- Converts verdict to JUnit XML format
- Publishes test results to GitHub
- Comments on PR with verification summary
- Uploads artifacts for review

## PR Comment Format

The workflow automatically comments on PRs with:

```markdown
## üîç Verification Report

**Task ID:** T_1234567890_abc12345
**Type:** code_update

### Verdict: ‚úÖ PASSED

**Reasons:**
- All 5 units completed
- Lint checks passed
- Tests passed with 95% coverage

**Artifacts Generated:** 8 files

---
*Generated by MCP Gemini Adjudicator* | [View Details](link)
```

## Workflow Configuration

### Environment Variables
Set these as GitHub Secrets:
- `GEMINI_API_KEY`: Google Gemini API key (optional, for LLM verification)

### Customization

#### Task Type Detection
Modify the task type logic in the workflow:
```yaml
- name: Determine task type
  run: |
    if echo "$CHANGED_FILES" | grep -qE '\.(js|ts|jsx|tsx)$'; then
      TASK_TYPE="code_update"
    # Add more patterns...
```

#### Adapter Selection
Configure in `config/adapter-plan.json`:
```json
{
  "code_update": {
    "order": ["code:diff", "code:lint", "code:tests"],
    "required": ["code:diff", "code:lint"]
  }
}
```

#### Verification Profiles
Set thresholds in `config/verification.profiles.json`:
```json
{
  "strict": {
    "lint_clean": true,
    "test_pass_required": true,
    "coverage_min": 80
  }
}
```

## Manual Trigger

Trigger the workflow manually with debug mode:

```bash
gh workflow run verify-claims.yml -f debug_mode=true
```

## Artifacts

The workflow uploads verification artifacts including:
- `commitment.json`: Initial task commitment
- `claim.json`: AI's claim about work done
- `artifacts.json`: Summary of all generated artifacts
- `verdict.json`: Final pass/fail verdict
- `junit.xml`: Test results for GitHub
- Adapter-specific artifacts (diffs, lint results, test coverage)

Access artifacts:
1. Go to Actions tab
2. Click on workflow run
3. Download "verification-artifacts-{task_id}"

## Status Badge

Add to your README:
```markdown
[![Verify Claims](https://github.com/YOUR_ORG/YOUR_REPO/actions/workflows/verify-claims.yml/badge.svg)](https://github.com/YOUR_ORG/YOUR_REPO/actions/workflows/verify-claims.yml)
```

## Troubleshooting

### Workflow Not Running
- Check workflow file exists at `.github/workflows/verify-claims.yml`
- Verify GitHub Actions is enabled for repository
- Check branch protection rules allow Actions

### Adapters Not Found
- Ensure adapter manifests exist in `adapters/*/manifest.json`
- Verify `tools/resolve-adapter.js` is executable
- Check adapter binaries have execute permissions

### Gate Always Passes
- Review verification profiles in `config/verification.profiles.json`
- Check if profile is being loaded correctly
- Verify artifacts are being generated

### PR Comment Not Appearing
- Check workflow has `pull-requests: write` permission
- Verify `GITHUB_TOKEN` is available
- Check PR number is correctly detected

## Best Practices

1. **Keep Adapters Deterministic**: Adapters should produce consistent results
2. **Set Appropriate Thresholds**: Balance strictness with practicality
3. **Monitor Workflow Duration**: Optimize long-running adapters
4. **Use Artifacts for Debugging**: Download and inspect for issues
5. **Leverage Fast Path**: Configure profiles for LLM-zero verdicts when possible

## Security Considerations

- Adapters run in sandboxed environment
- Network access controlled by manifest declarations
- Secrets never exposed in artifacts or logs
- PR comments sanitized to prevent injection

## Integration with Claude

When Claude makes changes and creates a PR:
1. Workflow automatically triggers
2. Verifies Claude's claims match actual changes
3. Reports verdict back to PR
4. Blocks merge if verification fails

This ensures Claude's work is always validated before merging.